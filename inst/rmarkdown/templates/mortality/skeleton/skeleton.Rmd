---
title: "Mortality survey"
output: word_document
---

# Introduction to this template

This is a template which can be used to create a report from a retrospective
mortality survey. 

- There are sections for reading and cleaning data, followed by 
    weighting and observation time calculations and then survey analysis. 
    Use the drop-down menu on the bottom left of this script window to jump 
    between sections. 
- You can type normal text in white spaces (such as here) and r-code in grey
    spaces (denoted by three backticks and r) (see [Rmarkdown
    introduction](https://rmarkdown.rstudio.com/articles_intro.html) and
    [Markdown basics](https://rmarkdown.rstudio.com/authoring_basics.html))
- Introductions and contents of sections are within square brackets "[...]" and
    can be deleted as appropriate
- Examples of inline code (to automate updating numbers, e.g. in the "Results
    section"), can similarly be removed/updated
- Code itself can be deleted, but as a word of caution: make sure you aren't
    deleting bits where variables are created/manipulated, or at least update
    them appropriatley
- For a more detailed exaplanation of this template, see [Wiki](https://github.com/R4EPI/sitrep/wiki)



## Installing and loading required packages 

Several packages are required for different aspects of  analysis with *R*. 
You will need to install these before starting. 
We will be using the following packages. Some of these packages automatically
install other packages they need to work (called dependencies).

These packages can be quite large and may take a while to download in the
field. If you have access to a USB key with these packages, it makes sense to
copy and paste the packages into Program Files/R/R-[version]/library.


```{r setup, include = FALSE, results='hide', message=FALSE, warning=FALSE}
# hide all code chunks in the output, but show errors
knitr::opts_chunk$set(echo = FALSE, error = TRUE, fig.width = 6*1.25, fig.height = 6)
# set default NA to - in output, define figure width/height
options(knitr.kable.NA = "-")

# Installing required packages for this template
required_packages <- c("knitr",       # create output docs
                       "dplyr",       # clean/shape data
                       "tidyr",       # clean/shape data
                       "forcats",     # clean/shape data
                       "ggplot2",     # create plots and charts
                       "sitrep",      # MSF field epi functions
                       "survey",      # for survey functions
                       "srvyr"        # dplyr wrapper for survey package
                       )

for (pkg in required_packages) {
  # install packages if not already present
  if (!pkg %in% rownames(installed.packages())) {
    install.packages(pkg)
  }
  
  # load packages to this current session 
  library(pkg, character.only = TRUE)
}
# set default text size to 16 for plots
# give classic black/white axes for plots
ggplot2::theme_set(theme_classic(base_size = 18))
```




```{r read_data_generic, message = FALSE}

## This section gives a variety of options for reading in datasets in different formats

## Read data ------------------------------------
# CSV file
# linelist_raw <- rio::import("linelist.csv")
#
# Excel file
# to read in a specific sheet use "which"
# linelist_raw <- rio::import("linelist.xlsx", which = "Sheet1")
#
# Stata data file
# linelist_raw <- rio::import("linelist.dat")
#
# For password protected Excel file 
# use the excel.link package 
# library(excel.link)
# linelist_raw <- excel.link::xl.read.file("linelist.xlsx",
#                                          xl.sheet = "Sheet1",
#                                          password = askpass::askpass(prompt = "please enter file
#                                                                      password"))

```




```{r read_dharma_excel_data, message = FALSE}

# If your linelist is an excel export of data from Dharma use this code chunk
# If that is not the case use the code chunk above reading in other formats

## Read data ------------------------------------------------------

# This assums that you have two levels in your survey (level 0 and level 1). 
# These correspond to, for example, household and individual. 
# We will read in and later merge these two levels in to one dataset. 
# We will assume the data is not password protected (code for reading 
# password protected excels is in the read_data_generic code chunk)

## read in household data sheet
# study_data_hh <- rio::import("mortality_survey.xlsx", 
#                               which = "Level 0 Named", na = ".")

## read in individual level data sheet
# study_data_indiv <- rio::import("mortality_survey.xlsx", 
#                               which = "Level 1 Named", na = ".")

## DELETE THIS LINE --- YOU READ IN YOUR OWN DATA ABOVE!
# generates a fake dataset for use as an example in this template
study_data_raw <- gen_data(dictionary = "Mortality", 
                         varnames = "column_name",
                         numcases = 1000)

## Data dictionary ---------------
## The data dictionary has variable names in the "column_name" column.
## Possible values for variables are specified in the "choice_code" and "choice_name"
## columns. 
## Where code has the shortened values and name has the full text values.

# read in data dictionary (for reference purposes)
# study_data_dict <- import("mortality_survey.xlsx",
#                       which = "Data Dictionary")

## you can look at the dictionary by uncommenting the line below
# View(study_data_dict) 

## you can view variable names in the data dicationry uncommenting the line below
# study_data_dict$column_name

## DELETE THIS LINE --- YOU READ IN YOUR OWN DATA ABOVE!
# generates a fake dataset for use as an example in this template
# this dataset already has the two levels merged
# variable names are in the column_name column
# possible values for each variable are specified in the "Code" columns.
study_data_dict <- msf_dict_survey("Mortality")
```


```{r merge_data_levels}

## Need to merge individual data with household data
## This is done using a unique identifier for the household 
## (which repeats in the individuals dataset) 
## For a Dharma dataset this variable is "fact_0_id"

## fact_0_id, the merging variable, needs to be applied to all relevant rows in the indidivual data set
## (equivalent of dragging down with mouse in excel)
## this is achieved using the fill function from the tidyr package
# study_data_indiv <- study_data_indiv %>%
#                       fill(fact_0_id)

## join the individual and household data to form a complete data set
#study_data_raw <- left_join(study_data_hh, study_data_indiv, by = "fact_0_id")
```




```{r read_population_data, warning = FALSE, message = FALSE}

## There are two options for using population data here. 
## The first one is where you only know the total population number, and the 
## proportion breakdown for categories (e.g. by age group, sex or region). 
## The second option is to read in population from excel. 
## In both cases you will need to make sure that the respective groups for 
## population fit the groups in your linelist data set!
##
## Checklist for population data ----------------------------------------------
## 
## - [ ] Decide if you have stratified population data available as counts or only proportions
## - [ ] If you have counts available:
##          - [ ] use View on the fake data generated to make sure your format in excel matches
##          - [ ] read in and clean data appropriately in the "Read data" section
##          - [ ] make sure the groups match the appropriate variable in your linelist!
## - [ ] If have total population and proportion breakdown available: 
##          - [ ] use the gen_population function in "counts from populaiton proportions" section
##          - [ ] type in your population, groups, and respective proportions
##          - [ ] group can be any categorical variable you want
##          - [ ] make sure the groups match the appropriate variable in your linelist!
## - [ ] DELETE OR COMMENT OUT THE UNUSED SECTION


## Read data ------------------------------------

## Excel file
## See the gen_population function section below to see how to structure your data!!
## to read in a specific sheet use "which"
# population_data <- rio::import("population.xlsx", which = "Sheet1")

## repeat same cleaning steps as in standardise_clean_data code chunk as appropriate
## make sure your place variable name matches!

## Counts from population proportions ------------------------------------ 
## if you only know the total population and the proportions in each age group, use this function 


# generate population data by age groups in years 
population_data_age <- gen_population(total_pop = 10000, # set the total population 
  groups = c("0-4", "5-14", "15-29", "30-44", "45+"),    # set the groups
  proportions = c(0.182, 0.278, 0.26, 0.11, 0.07),       # set the proportions for each group
  strata = c("Male", "Female")) %>%                      # stratify by gender 
  rename(age_group = groups,                        # rename columns (syntax is NEW NAME = OLD NAME)
         sex = strata,
         population = n)
```

```{r standardise_clean_data}

## All your data cleaning and new variable creation should happen in this chunk. 
## This way, if you mess up all you have to do is push the small arrow at the
## top of this chunk between the cogg and the play buttons, to run all the 
## code chunks up to the current one, then continue your cleaning from where you
## started. 
## 
## YOU WILL NEED TO ADAPT THIS SECTION ACCORDING TO YOUR DATA!
## 
## currently there are examples of cleaning for: 
##    - Date variables 
##    - Numeric variables 
##    - Categorical variables from numerics (e.g. age groups) 
##    - Factor variables (for creating/manipulating categorical variables)
##    - Adding weights based on population 
##    - Calculating observation time with start and end causes
##    - Dropping rows and columns 


## make a copy of your orginal dataset and name it study_data_cleaned
study_data_cleaned <- study_data_raw

# Rename variables  ---------------------------------
# Some of the names outputed from Dharma are really long and painful, you can change these as below
# The formula for this is rename(data, NEW_NAME = OLD_NAME). 

study_data_cleaned <- rename(study_data_cleaned, 
                              sex = q4_q6_sex, 
                              age_in_years = q155_q5_age_year)

# Date variables ---------------------------------

# IF YOU ARE USING A DHARMA DATA DICTIONARY USE THIS OTHERWISE UNCOMMENT LINES BELOW
# make sure all date variables are formatted as dates 

# select all variables which are dates using the data dictionary
# DATEVARS <- filter(study_data_dict, type == "QuestionDate") %>% 
#   select(column_name) # select date vars

# retrieving date vars from the fake dictionary (DELETE THIS)
DATEVARS <- filter(study_data_dict, data_element_valuetype == "DATE") %>% 
  select(column_name) # select date vars

# change to dates 
study_data_cleaned <- study_data_cleaned %>%
  mutate_at(DATEVARS$column_name, as.Date)

# if you dont have a data dictionary you could do it this way too
# study_data_cleaned <- study_data_cleaned %>%
#   mutate_at(vars(matches("date|Date")), as.Date)



# defining the recall period 
  # set the start of your recall-period
  # set the end of your recall period 
    # (when your survey stopped or day of survey questionnaire) 
    # IF day of questionnaire then use variable of date when form generated
study_data_cleaned <- study_data_cleaned %>% 
  mutate(recall_start = as.Date("2018-01-01"), 
         recall_end = as.Date("2018-05-01")
  )


# Ideally you should have defined rules in your forms to make sure dates collected are logical
# If not then uncomment the following lines to fix wrong dates (or set them to NA)
# Fixing wrong dates 
# set unrealistic dates to NA, based on having browsed dates in the previous chunk
# study_data_cleaned <- mutate(study_data_cleaned,
#                            date_of_onset < as.Date("2017-11-01") ~ as.Date(NA), 
#                            date_of_onset == as.Date("2081-01-01") ~ as.Date("2018-01-01"))

# set inappropriate dates to NA
# for arrivals and dirths before the recall period, set to NA 
# for deaths and departures after the recall period, set to NA
# study_data_cleaned <- study_data_cleaned %>% 
#   mutate(q114_q16_date_arrival_camp = ifelse(q114_q16_date_arrival_camp < recall_start, as.Date(NA), 
#                                              q114_q16_date_arrival_camp), 
#          q41_q25_hh_arrive_date = ifelse(q41_q25_hh_arrive_date < recall_start, as.Date(NA), 
#                                              q41_q25_hh_arrive_date), 
#          q88_q33_born_date = ifelse(q88_q33_born_date < recall_start, as.Date(NA), 
#                                              q88_q33_born_date), 
#          q45_q29_hh_leave_date = ifelse(q45_q29_hh_leave_date > recall_end, as.Date(NA), 
#                                              q45_q29_hh_leave_date), 
#          q137_q35_died_date = ifelse(q137_q35_died_date > recall_end, as.Date(NA), 
#                                              q137_q35_died_date)
#   )


# Age group variables ---------------------------------

# make sure age is an integer 
study_data_cleaned <- study_data_cleaned %>% 
  mutate(age_in_years = as.integer(age_in_years))

# create an age group variable by specifying categorical breaks (of years)
study_data_cleaned <- study_data_cleaned %>% 
  mutate(age_group = age_categories(age_in_years, 
                                    breakers = c(0, 5, 15, 30, 45)
                                    ))


# Factor (categorical) variables ---------------------------------

# Change a yes/no variable in to TRUE/FALSE
# create a new variable called died 
# where the old one is yes place TRUE in the new one
study_data_cleaned <- study_data_cleaned %>% 
  mutate(died = q136_q34_died == "Yes")

# Set the levels of a factor 
study_data_cleaned <- study_data_cleaned %>%
  mutate(cause_of_death = factor(q138_q36_died_cause,
                                 levels = c("Malaria/fever", "Diarrhoea", "Respiratory",
                                            "Trauma/accident", "Pregnancy-related", 
                                            "Violence", "Outbreak disease (specify)", 
                                            "Malnutrition", "Unknown", "Other (specify)")))

## change Dharma Multi-questions to TRUE/FALSE
SYMPTOMS <- grep("symptom", names(study_data_cleaned), value = TRUE) # get varsnames with symptom in
SYMPTOMS <- SYMPTOMS[-1] # drop the "other" symptoms free text var 

# set rows that are not empty to TRUE in each of the symptom variables
study_data_cleaned <- study_data_cleaned %>% 
  mutate_at(SYMPTOMS, .funs = ~ifelse(!is.na(.), TRUE, FALSE))

# define the labels for each of the symptoms 
SYMPTOMS_LABELS <- c("Diarrhoea", "Respiratory", "Malnutrition", 
                     "Pregnancy-related", "Malaria/fever", "Trauma", 
                     "Violence", "Unknown", "Other")

######## weighting ------------------------------------------------------------

study_data_cleaned <- add_weights(study_data_cleaned, population_data_age, age_group, sex)


#### observation time ----------------------------------------------------------

# create columns for start and end dates
# start date is the earliest appropriate arrival event within your recall period
  # this is either the begining of your recall period (which you define in advance)
  # or a date after the start of recall if applicable (e.g. arrivals or births)
# end date is the earliest appropriate departure event within your recall period
  # this is either the end of your recall period 
  # or a date before the end of recall if applicable (e.g. departures, deaths)


study_data_cleaned <- study_data_cleaned %>%
  # choose earliest date entered in survey
  # from births, household arrivals, and camp arrivals 
  find_start_date("q88_q33_born_date",
                  "q41_q25_hh_arrive_date",
                  "q114_q16_date_arrival_camp",
                  period_start = "recall_start",
                  period_end   = "recall_end",
                  datecol      = "startdate",
                  datereason   = "startcause" 
                 ) %>%
  # choose earliest date entered in survey
  # from camp departures, death and end of the study
  find_end_date("q45_q29_hh_leave_date",
                "q137_q35_died_date",
                period_start = "recall_start",
                period_end   = "recall_end",
                datecol      = "enddate",
                datereason   = "endcause" 
               )

# check that you do not have any negative observation times
# (e.g. any rows with end date before start date)
check_dates <- assert_positive_timespan(study_data_cleaned, startdate, enddate)

# return the unique identifiers which have negative observation time 
# (fact_0_id only exists in real dharma datasets - not those from gen_data function)
# check_dates$fact_0_id


# make sure there are the appropriate levels (names)
study_data_cleaned$startcause <- recode_factor(study_data_cleaned$startcause, 
                                               "Present at start" = "Present at start",
                                               "q88_q33_born_date" = "Born", 
                                               "q114_q16_date_arrival_camp" = "Other arrival", 
                                               "q41_q25_hh_arrive_date" = "Other arrival"
                                               )

# make sure there are the appropriate levels (names)
study_data_cleaned$endcause <- recode_factor(study_data_cleaned$endcause, 
                                             "Present at end" = "Present at end", 
                                             "q137_q35_died_date" = "Died", 
                                             "q45_q29_hh_leave_date" = "Other departure")


## Define observation time in days (need to highlight if negatives occur)
study_data_cleaned <- study_data_cleaned %>% 
  mutate(obstime = as.numeric(enddate - startdate))

# drop unwanted rows  ---------------------------------------------------------

# you may want to drop rows with missing IDs (i.e. blank rows from excel) 
  # simply add a !is.na(fact_0_id) if using a dharma dataset
# you will also want to drop those rows where both the start and enddate occur
# outside of your recall period! 
study_data_cleaned <- study_data_cleaned %>%
  filter(!is.na(startcause) | !is.na(endcause))

```

```{r save_cleaned_data, eval = FALSE}
## OPTIONAL: save your cleaned dataset as an excel file! 
## put the current date in the name so you know!
writexl::write_xlsx(study_data_cleaned, paste0("study_data_cleaned_", Sys.Date(), ".xlsx")
```


```{r survey_design}
## USE THIS TO SET THE STUDY DESIGN FOR YOUR SURVEY  ---------------------------
##
## This creates "survey objects" which can be used as data frames for calculating
## weighted proportions etc. 
## There are several options for study design here. 
## At the basic level you want to decide if it is a simple random or a cluster
## design study. You will then need to identify your weights variable. 
## You can also create several study designs, e.g. if you would like to have
## an overall design and a stratified design (e.g. by sex or by region). 
##
## Checklist for study design --------------------------------------------------
## 
## - [ ] Make sure you have created all necessary variables in earlier code chunks!!
## - [ ] Decide on your study design (cluster or simple random)
## - [ ] If doing cluster:
##          - [ ] place your cluster ID variable in the ids option 
##                (e.g. householdID - "fact_0_id" not availble in dat dict)
##          - [ ] specify your weight variable (created previously)
##                (set to NULL if want no weights)
## - [ ] If doing simple random: 
##          - [ ] set ids equals 1 to have no clustering 
##          - [ ] specify your weight variable (created previously)
##                (set to NULL if want no weights)
## - [ ] Create additional study designs based on strata 
##      (make sure that your weight variable is based on appropriately stratified
##        population data)


# simple random sample (using srvyr package)
survey_design <- study_data_cleaned %>% 
  as_survey_design(ids = 1, # 1 for no cluster ids 
                   weights = weight # weight variable created above 
                   )


# simple random sample stratified by sex 
survey_design_sex <- study_data_cleaned %>% 
  as_survey_design(ids = 1, # 1 for no cluster ids 
                   weights = weight, # weight variable created above 
                   strata = sex
                   )
```


# Results

A total of `r nrow(study_data_cleaned)` surveyed individuals were included in the analyses. There were `r fmt_count(study_data_cleaned, startcause == "Present at start")` household members present at the start of the recall period. There were `r fmt_count(study_data_cleaned, startcause != "Present at start")` individuals who arrived during the recall period and `r fmt_count(study_data_cleaned, endcause != "Present at end")` who departed. This resulted in `r fmt_count(study_data_cleaned, endcause == "Present at end")` individuals who were present at the end of the recall period; for a net change in sample population of 
`r round( ( 1 - abs(tally(study_data_cleaned, startcause == "Present at start") - tally(study_data_cleaned, endcause == "Present at end")) / tally(study_data_cleaned, startcause == "Present at start")) * 100, digits = 1)`%. 

Below shows the arrivals and departures during the study period. 
TO DO: Add example text of inline code - e.g. to show the net change in population. 

```{r}
descriptive(study_data_cleaned, 
            "startcause", coltotals = TRUE) %>% 
  kable(digits = 2)
```


```{r}
descriptive(study_data_cleaned, 
            "endcause", coltotals = TRUE) %>% 
  kable(digits = 2)
```



## Demographic information

Compare the proportions in each age group between your sample and the source population. 

```{r}
# bind together the columns of two tables 
bind_cols(
  # first the counts and props of the study population 
  descriptive(study_data_cleaned, 
              "age_group"), 
  
  # then the counts and props of the source population
  group_by(population_data_age, age_group) %>% 
    summarise(n = sum(population)) %>% 
    mutate(prop = round(n / sum(n) * 100, digits = 1))  %>% 
    select(-age_group)
) %>% 
  # rename the columns appropriatley 
  rename("Age group" = age_group, 
         "Study population (n)" = n, 
         "%" = prop, 
         "Source population (n)" = n1, 
         "%" = prop1) %>% 
  kable(digits = 2)

```




TODO: add some sample text with inline R

Age distribution of current household population by five year age groups, dependency age groups, and by child and adult populations, by gender.
```{r describe_by_age_group_and_sex}
descriptive(study_data_cleaned, 
            "age_group", 
            "sex", 
            rowtotals = TRUE, 
            coltotals = TRUE, proptotal = TRUE) %>% 
  rename("Age" = age_group, 
         "Female cases (n)" = Female_n, 
         "%" = Female_prop, 
         "Male cases (n)" = Male_n, 
         "%" = Male_prop) %>% 
  kable(digits = 2)
```


Age and gender distribution of household population covered by the survey.
```{r age_pyramid}
plot_age_pyramid(study_data_cleaned, 
                 age_group = "age_group", 
                 split_by = "sex",
                 proportion = TRUE) + 
  labs(y = "Proportion", x = "Age group (years)") +                    # change axis labels
  theme(legend.position = "bottom", legend.title = element_blank())   # remove title and move legend
```

Weighted age distribution - if this is substantially different to your unweighted 
pyramid, then it may suggest some sampling bias. 
```{r age_pyramid_survey}
plot_age_pyramid(survey_design_sex,
                 age_group = "age_group",
                 split_by = "sex", 
                 proportion = TRUE) +
  labs(y = "Proportion", x = "Age group (years)") +                    # change axis labels
  theme(legend.position = "bottom", legend.title = element_blank())   # remove title and move legend
```


## Mortality

Reported causes of death and cause-specific mortality rates, weighted

```{r}

# you will get separate columns, for weighted counts (weighted % with CI), 
# and mortality per 10,000 persons/day with CI
cause_of_death_prop <- survey_design %>% 
  group_by(cause_of_death) %>% 
  summarize(n = survey_total(vartype = "se", na.rm = TRUE),
            proportion = survey_mean(vartype = "ci", na.rm = TRUE)
            ) %>% 
  mutate(n = round(n)) %>% 
  select(-n_se)

cause_of_death_mort <- survey_design %>% 
  group_by(cause_of_death) %>% 
  summarize( mortality = survey_ratio(as.numeric(died) * 10000, obstime, vartype = "ci")) 

dplyr::left_join(cause_of_death_prop, cause_of_death_mort) %>% 
  unite_ci("% (95% CI)", starts_with("proportion"), m100 = TRUE, percent = FALSE, digits = 1) %>%
  unite_ci("Mortality per 10,000 persons/day (95% CI)", starts_with("mortality"), m100 = FALSE, percent = FALSE) %>%
  kable()


```

Reported causes of death and cause-specific mortality rates, by age, weighted
```{r}

survey_design %>% 
  tabulate_survey(cause_of_death, age_group) %>%
  kable()

```

Reported causes of death and cause-specific mortality rates, by gender, weighted
```{r}
survey_design %>% 
  tabulate_survey(cause_of_death, sex) %>%
  kable()

```

## Morbidity





```{r}
# symptoms reported among those who were sick 
survey_design %>% 
  filter(q18_q8_sick == "Yes") %>% 
  tabulate_binary_survey(SYMPTOMS, keep = TRUE, method = "xlogit") %>%
  mutate(variable = SYMPTOMS_LABELS) %>% 
  select(-value)
```

# Conclusions

# Recommendations

# References

